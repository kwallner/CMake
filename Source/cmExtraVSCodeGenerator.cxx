/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file Copyright.txt or https://cmake.org/licensing for details.  */
#include "cmExtraVSCodeGenerator.h"

#include <cstring>
#include <memory>
#include <ostream>
#include <set>
#include <vector>

#include "cmGeneratedFileStream.h"
#include "cmGeneratorTarget.h"
#include "cmGlobalGenerator.h"
#include "cmLocalGenerator.h"
#include "cmMakefile.h"
#include "cmSourceFile.h"
#include "cmStateTypes.h"
#include "cmStringAlgorithms.h"
#include "cmSystemTools.h"

#include "cm_jsoncpp_value.h"
#include "cm_jsoncpp_writer.h"

#include <iostream> // FIXME: Remove, Just for temp debug

cmExtraVSCodeGenerator::cmExtraVSCodeGenerator() = default;

cmExternalMakefileProjectGeneratorFactory* cmExtraVSCodeGenerator::GetFactory()
{
  static cmExternalMakefileProjectGeneratorSimpleFactory<cmExtraVSCodeGenerator>
    factory("VSCode", "Generates VSCode project files.");

  if (factory.GetSupportedGlobalGenerators().empty()) {
#if defined(_WIN32)
    factory.AddSupportedGlobalGenerator("MinGW Makefiles");
    factory.AddSupportedGlobalGenerator("NMake Makefiles");
    // disable until somebody actually tests it:
    // factory.AddSupportedGlobalGenerator("MSYS Makefiles");
#endif
    factory.AddSupportedGlobalGenerator("Ninja");
    factory.AddSupportedGlobalGenerator("Unix Makefiles");
  }

  return &factory;
}

/*
template <typename T> inline Json::Value make_json_value(const std::string& key, const T& value)
{
  Json::Value res(Json::objectValue);
  res[key] = value;
  return res;
}*/

void cmExtraVSCodeGenerator::Generate()
{
  const auto& lg = this->GlobalGenerator->GetLocalGenerators()[0];
  const cmMakefile* mf = lg->GetMakefile();

  // CMake Configuration values are dcoumented:
  // https://vector-of-bool.github.io/docs/vscode-cmake-tools/settings.html
  Json::Value settings(Json::objectValue);
  settings["cmake.buildDirectory"] = lg->GetBinaryDirectory(); // "${workspaceRoot}";

  settings["cmake.cmakePath"] = cmSystemTools::GetCMakeCommand();
  const std::string& installPrefix = mf->GetSafeDefinition("CMAKE_INSTALL_PREFIX");
  if (!installPrefix.empty()) {
    settings["cmake.installPrefix"] = installPrefix;
  }
  settings["cmake.sourceDirectory"] = lg->GetSourceDirectory();

#if 0
  settings["cmake.buildBeforeRun"] = true; // default
  settings["cmake.saveBeforeBuild"] = true; // default
  settings["cmake.configureOnOpen"] = true;
  settings["cmake.buildTask"] = true;
  settings["cmake.generator"] = "VSCode - MinGW Makefiles"; // TODO
  Json::Value configureSettings(Json::objectValue);
  std::vector<std::string> definitions = mf->GetDefinitions();
  for (const std::string& definiton : definitions) {
    std::cerr << "Definition: " << definiton << std::endl;
  }
  configureSettings["CMAKE_EXPORT_NO_PACKAGE_REGISTRY"] = "ON";
  settings["cmake.configureSettings"] = configureSettings;
  Json::Value configureArgs(Json::arrayValue);
  configureArgs.append(Json::Value("-DCONAN_CMAKE_CXX_STANDARD=14"));
  settings["cmake.configureArgs"] = configureArgs;
#endif

  Json::StreamWriterBuilder builder;
  builder["indentation"] = "    ";

  std::string dummy_cmake_list_file = lg->GetBinaryDirectory() + "/CMakeLists.txt";
  if (!cmSystemTools::FileExists(dummy_cmake_list_file))
  {
    // Dummy CMakeLists.txt is needed to enable cmake extensions
    cmsys::ofstream fout(dummy_cmake_list_file.c_str());
    fout << "#Generated by " << cmSystemTools::GetCMakeCommand()
      << ", do not edit.\n";
    fout.close();
  }

  std::string settings_file_path = lg->GetBinaryDirectory() + "/.vscode";
  cmSystemTools::MakeDirectory(settings_file_path);
  settings_file_path += "/settings.json";
  {
    cmsys::ofstream fout(settings_file_path.c_str());
    std::unique_ptr<Json::StreamWriter> json_writer(builder.newStreamWriter());

    if (json_writer->write(settings, &fout)) {
      // TODO: Might report an error ... but function yet always returns 0
      return;
    }
    fout.close();
  }
}

