/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file Copyright.txt or https://cmake.org/licensing for details.  */
#include "cmExtraVSCodeGenerator.h"

#include <cstring>
#include <memory>
#include <ostream>
#include <set>
#include <vector>

#include "cmGeneratedFileStream.h"
#include "cmGeneratorTarget.h"
#include "cmGlobalGenerator.h"
#include "cmLocalGenerator.h"
#include "cmMakefile.h"
#include "cmSourceFile.h"
#include "cmStateTypes.h"
#include "cmStringAlgorithms.h"
#include "cmSystemTools.h"

#include "cm_jsoncpp_value.h"
#include "cm_jsoncpp_reader.h"
#include "cm_jsoncpp_writer.h"

#include <iostream> // FIXME: Remove, Just for temp debug

cmExtraVSCodeGenerator::cmExtraVSCodeGenerator() = default;

cmExternalMakefileProjectGeneratorFactory* cmExtraVSCodeGenerator::GetFactory()
{
  static cmExternalMakefileProjectGeneratorSimpleFactory<cmExtraVSCodeGenerator>
    factory("VSCode", "Generates VSCode project files.");

  if (factory.GetSupportedGlobalGenerators().empty()) {
#if defined(_WIN32)
    factory.AddSupportedGlobalGenerator("MinGW Makefiles");
    factory.AddSupportedGlobalGenerator("NMake Makefiles");
    // disable until somebody actually tests it:
    // factory.AddSupportedGlobalGenerator("MSYS Makefiles");
#endif
    factory.AddSupportedGlobalGenerator("Ninja");
    factory.AddSupportedGlobalGenerator("Unix Makefiles");
  }

  return &factory;
}

/*
template <typename T> inline Json::Value make_json_value(const std::string& key, const T& value)
{
  Json::Value res(Json::objectValue);
  res[key] = value;
  return res;
}*/

void cmExtraVSCodeGenerator::Generate()
{
  const auto& lg = this->GlobalGenerator->GetLocalGenerators()[0];

  // Create directories
  std::string settings_file_path = lg->GetBinaryDirectory() + "/.vscode";
  cmSystemTools::MakeDirectory(settings_file_path);
  settings_file_path += "/settings.json";
  Json::Value settings(Json::objectValue);

  // Read in values
  {
    Json::CharReaderBuilder builder;
    builder["collectComments"] = false;
    JSONCPP_STRING errs;
    if (cmSystemTools::FileExists(settings_file_path))
    {
      cmsys::ifstream fin(settings_file_path.c_str());
      bool ok = parseFromStream(builder, fin, &settings, &errs);
      // FIXME: Might report errors !!!
    }
  }

  // Set values
  bool values_changed = false;
  {
    const cmMakefile* mf = lg->GetMakefile();

    // CMake Configuration values are documented:
    // https://vector-of-bool.github.io/docs/vscode-cmake-tools/settings.html

    // set "buildDirectory"
    if (settings["cmake.buildDirectory"] != lg->GetBinaryDirectory())
    {
      settings["cmake.buildDirectory"] = lg->GetBinaryDirectory();
      values_changed = true;
    }

    // set "cmakePath"
    if (settings["cmake.cmakePath"] != cmSystemTools::GetCMakeCommand()) {
      settings["cmake.cmakePath"] = cmSystemTools::GetCMakeCommand();
      values_changed = true;
    }

    // set "installPrefix"
    const std::string& installPrefix = mf->GetSafeDefinition("CMAKE_INSTALL_PREFIX");
    if (installPrefix.empty()) {
      const char* key = "cmake.installPrefix";
      if (settings.find(key, key + strlen(key))) {
        // Remove installPrefix
        settings.removeMember(key);
      }
    }
    else {
      if (settings["cmake.installPrefix"] != installPrefix)
      {
        settings["cmake.installPrefix"] = installPrefix;
        values_changed = true;
      }
    }

    // set "sourceDirectory"
    if (settings["cmake.sourceDirectory"] != lg->GetSourceDirectory()) {
      settings["cmake.sourceDirectory"] = lg->GetSourceDirectory();
      values_changed = true;
    }
  }

  // Write values
  if (values_changed) {
    Json::StreamWriterBuilder builder;
    builder["indentation"] = "    ";

    cmsys::ofstream fout(settings_file_path.c_str());
    std::unique_ptr<Json::StreamWriter> json_writer(builder.newStreamWriter());

    if (json_writer->write(settings, &fout)) {
      // TODO: Might report an error ... but function yet always returns 0
      return;
    }
    fout.close();
  }

  // CMake-File
  std::string dummy_cmake_list_file = lg->GetBinaryDirectory() + "/CMakeLists.txt";
  if (!cmSystemTools::FileExists(dummy_cmake_list_file))
  {
    // Dummy CMakeLists.txt is needed to enable cmake extensions
    cmsys::ofstream fout(dummy_cmake_list_file.c_str());
    fout << "#Generated by " << cmSystemTools::GetCMakeCommand()
      << ", do not edit.\n";
    fout.close();
  }
}

